<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TKS AI</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/>
  <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', sans-serif;
        }

        body {
            background: #0a0e17;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .container {
            background: url('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSkCiflFM3EqyMRt5fmJTgrtUsChEb3sXIyNUdlQ2gbRY3pJpHHfwwidS08&s=10') no-repeat center center/cover;
            width: 390px;
            height: 844px;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
            margin-top: -5vh; /* Adjusted to move 30% up */
        }

        .status-bar {
            display: flex;
            justify-content: flex-end;
            padding: 10px;
            color: #64748b;
            font-size: 0.9em;
        }

        .main-display {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .main-display::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
        }

        .period-number {
            font-family: "Lucida Console", "Courier New", monospace;
            font-size: 1.8em;
            font-weight: 700;
            color: #3399ff;
            margin-bottom: 10px;
        }

        .result-display {
            font: italic small-caps bold 12px/30px Georgia, serif;
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #4dffff;
        }

        .additional-container,
        .recent-data {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .main-display h1,
        .additional-container h2,
        .recent-header span {
            font: italic small-caps bold 12px/30px Georgia, serif;
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #00FF00;
        }

        .additional-container::after,
        .recent-data::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
        }

        .additional-container {
            text-align: center;
            color: #f0db4f;
        }

        .recent-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .data-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #0000ff;
        }

        .data-item:last-child {
            border-bottom: none;
        }

        .data-label {
            font-weight: bold;
            color: #4dffff;
        }

        .data-value {
            font-weight: bold;
            color: #ff0000;
        }

        .data-list {
            max-height: calc(3 * 50px); /* Limit to 3 items */
            overflow-y: hidden;
            position: relative;
        }

        .data-list::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(10, 14, 23, 1));
            pointer-events: none;
        }

        .refresh-button {
            position: fixed;
            bottom: 40px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #1c2535, #212c3f);
            border: 2px solid #00ff00; /* Button border added here */
            border-radius: 50%;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.2), -5px -5px 15px rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 999;
        }

        .refresh-button i {
            color: #ffff00;
            font-size: 1.5em;
        }

.get-result {
    background: rgba(0, 0, 0, 0.2);
    color: #00ff00;
    font-size: 0.8em; /* Smaller font size */
    padding: 5px 10px; /* Reduced padding */
    border: 2px solid #00ff00;
    border-radius: 10px; /* Reduced border radius */
    cursor: pointer;
    transition: 0.3s;
}

.get-result:hover {
    background: white;
    color: black;
}

        .info-box {
            display: flex;
            font-size: bold;
            font-family: "Lucida Console", "Courier New", monospace;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff00;
            border-radius: 7px;
            padding: 8px;
            margin-bottom: 10px;
        }

        .info-box i {
            font-size: 1.5rem;
            color: #00ff00;
        }

        .info-box span {
            font-size: bold;
            font: italic small-caps bold 12px/30px Georgia, serif;
            font-size: 0.9rem;
            flex-grow: 1;
            margin-left: 10px;
            color: #ffffff;
            text-align: left;
        }

        .status {
            font-family: "Lucida Console", "Courier New", monospace;
            font-size: 1.5rem;
            color: #00ff00;
            margin: 20px 0;
        }
        

        
        
        
    </style>
</head>
<body>
  <div class="container">
    <div class="status-bar"></div>

    <div class="main-display">
      <h1>Ak Ultra Mod 2.5</h1>
      <div class="period-number" id="period-number">Loading...</div>
      <div class="result-display">
        <i class="fa fa-refresh fa-spin"></i> <span id="result">Loading...</span>
      </div>
      <div class="confidence-meter">
        <div class="confidence-level" id="confidence-level"></div>
      </div>
    </div>

    <div class="recent-data">
      <div class="recent-header">
        <span>Recent Results</span>
        <span><i class="fa fa-history"></i></span>
      </div>
      <div class="data-list" id="history-list"></div>
    </div>

    <button class="refresh-button" onclick="refreshPrediction()">
      <i class="fa fa-refresh fa-spin"></i>
    </button>
  </div>

  <script>
    // Enhanced prediction algorithm based on last 4 digits of period number
    class PredictionEngine {
      constructor() {
        this.history = [];
        this.patterns = {};
        this.lastUpdate = 0;
      }
      
      // Analyze last 4 digits of period number
      analyzePeriodDigits(period) {
        const periodStr = period.toString();
        const last4 = periodStr.slice(-4).split('').map(Number);
        
        // Calculate various mathematical properties
        const sum = last4.reduce((a, b) => a + b, 0);
        const product = last4.reduce((a, b) => a * b, 1);
        const digitSum = sum.toString().split('').map(Number).reduce((a, b) => a + b, 0);
        const digitProduct = product.toString().split('').map(Number).reduce((a, b) => a * b, 1);
        
        // Calculate digit patterns
        const ascending = last4.every((val, i, arr) => i === 0 || val >= arr[i - 1]);
        const descending = last4.every((val, i, arr) => i === 0 || val <= arr[i - 1]);
        
        // Calculate digit differences
        const diff1 = Math.abs(last4[0] - last4[1]);
        const diff2 = Math.abs(last4[1] - last4[2]);
        const diff3 = Math.abs(last4[2] - last4[3]);
        
        return {
          digits: last4,
          sum,
          product,
          digitSum,
          digitProduct,
          ascending,
          descending,
          differences: [diff1, diff2, diff3],
          evenCount: last4.filter(d => d % 2 === 0).length,
          oddCount: last4.filter(d => d % 2 !== 0).length
        };
      }
      
      // Generate prediction based on period number analysis
      generatePrediction(period) {
        const analysis = this.analyzePeriodDigits(period);
        const history = this.history.slice(0, 10); // Last 10 results
        
        // Weighted factors for prediction
        const factors = {
          sumMod: analysis.sum % 10,
          productMod: analysis.product % 10,
          digitSumMod: analysis.digitSum % 10,
          digitProductMod: analysis.digitProduct % 10,
          lastDigit: analysis.digits[3],
          secondLastDigit: analysis.digits[2],
          evenOddRatio: analysis.evenCount / (analysis.oddCount || 1),
          historyTrend: this.calculateHistoryTrend(history),
          digitPattern: this.calculateDigitPattern(analysis.digits)
        };
        
        // Calculate weighted prediction (adjusted weights for new method)
        let predictionValue = Math.round(
          (factors.sumMod * 0.15) +
          (factors.productMod * 0.15) +
          (factors.digitSumMod * 0.15) +
          (factors.digitProductMod * 0.1) +
          (factors.lastDigit * 0.2) +
          (factors.secondLastDigit * 0.1) +
          (factors.evenOddRatio * 5) +
          (factors.historyTrend * 0.05) +
          (factors.digitPattern * 0.1)
        ) % 10;
        
        // Ensure prediction is between 0-9
        predictionValue = Math.abs(predictionValue);
        if (predictionValue > 9) predictionValue = 9;
        
        const size = predictionValue <= 4 ? 'Small' : 'Big';
        const confidence = this.calculateConfidence(analysis, factors);
        
        return {
          prediction: `${size}(${predictionValue})`,
          confidence,
          analysis
        };
      }
      
      calculateDigitPattern(digits) {
        // Check for repeating digits
        const uniqueDigits = [...new Set(digits)];
        if (uniqueDigits.length === 1) return 0; // All digits same
        
        // Check for pairs
        const digitCounts = {};
        digits.forEach(d => digitCounts[d] = (digitCounts[d] || 0) + 1);
        const pairs = Object.values(digitCounts).filter(count => count >= 2).length;
        
        if (pairs >= 2) return 5; // Multiple pairs
        if (pairs === 1) return digits[3]; // Single pair
        
        // Check sequential patterns
        const diff1 = digits[1] - digits[0];
        const diff2 = digits[2] - digits[1];
        const diff3 = digits[3] - digits[2];
        
        if (diff1 === diff2 && diff2 === diff3) {
          return Math.abs(diff1); // Arithmetic sequence
        }
        
        return digits[3]; // Default to last digit
      }
      
      calculateHistoryTrend(history) {
        if (history.length < 3) return 5; // Neutral value
        
        const lastThree = history.slice(0, 3);
        const smallCount = lastThree.filter(r => r.number <= 4).length;
        const bigCount = lastThree.filter(r => r.number > 4).length;
        
        if (smallCount > bigCount) return 3; // Slightly favor small
        if (bigCount > smallCount) return 7; // Slightly favor big
        return 5; // Neutral
      }
      
      calculateConfidence(analysis, factors) {
        // Calculate consistency between different methods
        const methods = [
          factors.sumMod,
          factors.productMod,
          factors.digitSumMod,
          factors.lastDigit,
          factors.digitPattern
        ];
        
        // Count how many methods agree with the final prediction
        const finalPred = factors.sumMod; // Using sumMod as base for comparison
        const agreementCount = methods.filter(m => m === finalPred).length;
        
        // Confidence based on agreement (0-5 methods agreeing)
        let confidence = 50 + (agreementCount * 10);
        
        // Adjust based on digit patterns
        if (analysis.ascending || analysis.descending) confidence += 10;
        if (analysis.evenCount === 4 || analysis.oddCount === 4) confidence += 5;
        
        // Keep within reasonable bounds
        return Math.max(30, Math.min(95, confidence));
      }
      
      updateHistory(newHistory) {
        this.history = newHistory;
        this.lastUpdate = Date.now();
      }
    }

    // Initialize prediction engine
    const predictionEngine = new PredictionEngine();

    async function fetchCurrentGameIssue() {
      const apiUrl = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
      const requestData = {
        "typeId": 1,
        "language": 0,
        "random": "40079dcba93a48769c6ee9d4d4fae23f",
        "signature": "D12108C4F57C549D82B23A91E0FA20AE",
        "timestamp": Math.floor(Date.now() / 1000)
      };

      try {
        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json;charset=UTF-8',
            'Accept': 'application/json, text/plain, */*'
          },
          body: JSON.stringify(requestData)
        });

        if (response.ok) {
          const data = await response.json();
          if (data.code === 0) {
            updateCurrentPrediction(data.data.issueNumber);
          } else {
            console.error('Failed to fetch game issue:', data.msg);
          }
        } else {
          console.error('Network response was not ok:', response.statusText);
        }
      } catch (error) {
        console.error('Fetch error:', error);
      }
    }

    function updateCurrentPrediction(issueNumber) {
      const storedPredictionPeriod = localStorage.getItem('currentPeriod');
      const storedPredictionResult = localStorage.getItem('predictionResult');

      if (storedPredictionPeriod === issueNumber) {
        document.getElementById('result').textContent = storedPredictionResult;
      } else {
        const { prediction, confidence } = predictionEngine.generatePrediction(issueNumber);
        localStorage.setItem('currentPeriod', issueNumber);
        localStorage.setItem('predictionResult', prediction);
        document.getElementById('result').textContent = prediction;
        document.getElementById('confidence-level').style.width = `${confidence}%`;
      }
      document.getElementById('period-number').textContent = issueNumber;
    }

    async function fetchPreviousResults() {
      const apiUrl = 'https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList';
      const requestData = {
        "pageSize": 10,
        "pageNo": 1,
        "typeId": 1,
        "language": 0,
        "random": "c2505d9138da4e3780b2c2b34f2fb789",
        "signature": "7D637E060DA35C0C6E28DC6D23D71BED",
        "timestamp": Math.floor(Date.now() / 1000)
      };

      try {
        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json;charset=UTF-8',
            'Accept': 'application/json, text/plain, */*'
          },
          body: JSON.stringify(requestData)
        });

        if (response.ok) {
          const data = await response.json();
          if (data.code === 0) {
            updateHistoryTable(data.data.list);
          } else {
            console.error('Failed to fetch previous results:', data.msg);
          }
        } else {
          console.error('Network response was not ok:', response.statusText);
        }
      } catch (error) {
        console.error('Error fetching previous results:', error);
      }
    }

    function updateHistoryTable(historyList) {
      const historyContainer = document.getElementById('history-list');
      historyContainer.innerHTML = '';

      const historyData = [];

      historyList.forEach(result => {
        const { issueNumber, number, colour } = result;
        const size = number <= 4 ? 'Small' : 'Big';

        const item = document.createElement('div');
        item.className = 'data-item';

        const label = document.createElement('span');
        label.className = 'data-label';
        label.innerHTML = `<i class="fa fa-calendar"></i> ${issueNumber}`;
        item.appendChild(label);

        const value = document.createElement('span');
        value.className = 'data-value';
        value.textContent = `${size} (${number})`;
        item.appendChild(value);

        historyContainer.appendChild(item);

        historyData.push({ issueNumber, number, colour });
      });

      // Update prediction engine with new history
      predictionEngine.updateHistory(historyData);
      localStorage.setItem('historyData', JSON.stringify(historyData));
    }

    async function refreshPrediction() {
      try {
        await fetchCurrentGameIssue();
        await fetchPreviousResults();
        
        // Add slight delay to show refresh animation
        const refreshIcon = document.querySelector('.refresh-button i');
        refreshIcon.classList.add('fa-spin');
        setTimeout(() => {
          refreshIcon.classList.remove('fa-spin');
        }, 1000);
      } catch (error) {
        console.error('Refresh error:', error);
      }
    }

    // Initialize on page load
    document.addEventListener("DOMContentLoaded", function () {
      // Load any cached data first for quick display
      const cachedPeriod = localStorage.getItem('currentPeriod');
      const cachedResult = localStorage.getItem('predictionResult');
      const cachedHistory = localStorage.getItem('historyData');
      
      if (cachedPeriod) {
        document.getElementById('period-number').textContent = cachedPeriod;
      }
      
      if (cachedResult) {
        document.getElementById('result').textContent = cachedResult;
      }
      
      if (cachedHistory) {
        try {
          const history = JSON.parse(cachedHistory);
          predictionEngine.updateHistory(history);
          updateHistoryTable(history.slice(0, 3)); // Only show 3 in UI
        } catch (e) {
          console.error('Error parsing cached history:', e);
        }
      }
      
      // Then fetch fresh data
      refreshPrediction();
      
      // Set up periodic refresh (every 30 seconds)
      setInterval(refreshPrediction, 10000);
    });
  </script>
</body>
</html>
